# MySQL学习笔记

## 一、MySQL系统架构

### （一）架构组成
mysql服务架构分为
- 连接层
- 服务层
- 引擎层

![img.png](src/img.png)

![img1.png](src%2Fimg1.png)

![img.png](img.png)

### （二）SQL的执行过程
SQL语句 -> 查询缓存 -> 解析器 -> 优化器 -> 执行器
![img_1.png](img_1.png)

#### 1.解析器
- 词法分析

- 语法分析
  

#### 2.优化器
- 逻辑优化
  - 逻辑查询优化就是通过 SQL 等价变换 提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。
- 物理优化
  - 物理查询优化则是通过 索引和 表连接方式 等技术来进行优化，这里重点需要掌握索引的使用。

#### 3.执行器

### （三）数据库缓冲池（Buffer Pool）

首先我们需要了解在innoDB 存储引擎中，缓冲池都包括了哪些。
在innoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的
缓存，如下图所示:
![img_2.png](img_2.png)
从图中，你能看到InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等

##### 缓存池的重要性:
对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引(包括聚族索引和二级索引)，还是各种系统数据，都是以 <font color='red'>页</font> 的形式存放在 表空间 中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上“快如风，疾如电”的CPU 呢?这里，缓冲池可以帮助我们消除CPU和磁盘之间的 鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把 完整的页的数据全部加载到内存中也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 缓存起来，这样将来有请求再次访问该页面时，就可以 省去磁盘IO的开销了。

##### 缓存原则:
“ 位置 * 频次 ” 这个原则，可以帮我们对I/0 访问效率进行优化
首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。
其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高的热数据进行加载。

##### 缓冲池的预读特性
了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性: 预读。缓冲池的作用就是提升 I/O 效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 /0 操作。

#### 2.缓冲池如何读取数据
缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。
缓存在数据库中的结构和作用如下图所示:
![img_3.png](img_3.png)

<font color='red'>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?</font>

实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新 到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checipoint 的机制 将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。比如，当缓冲池不够用 时，需要释放掉一些不常用的页，此时就可以强行采用 checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页 (dirty page)指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。


#### 3.设置缓存池大小
```sql
#设置缓存池大小为1G
set global innodb_buffer_pool_size = 1073741824
show VARIABLES like '%buffer_pool%'
```

#### 4.多个Buffer Pool实例
Buffer Pool本质是InnoDB向操作系统申请的一块 连续的内存空间，在多线程环境下，访问Bufer Pool中的数据都票要加锁处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们拆分成若千个小的Buffer Pool，每个Buffer Pool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。
我们可以在服务器启动的时候通过设置 innodb_buffer-pool_instances 的值来修改Buffer Pool实例的个数比方说这样:
```properties
[server]
innodb_buffer_pool_instance = 2
```
这样就表明我们要创建2个 Buffer Pool 实例
不过也不是说Buffer Pool实例创建的越多越好，分别管理各个Buffer Pool也是需要性能开销的
innoDB规定:当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。而我们鼓励在Buffer Pool大于或等于1G的时候设置多个Buffer Pool实例。

### （四）存储引擎
```sql
show ENGINES;
```

#### 1.InnoDB引擎：具备外键支持功能的分事务存储引擎
- MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎。
- InnoDB是MySQL的 默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。
- 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎
- 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎
- 数据文件结构: 
  - 表名.frm 存储表结构 (MySQL8.0时，合并在表名.ibd中)
  - 表名.ibd 存储数据和索引
- InnoDB是 为处理巨大数据量的最大性能设计
  - 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如: .frm， .par， .trn， .isl， .db.opt 等都在MySQL8.0中不存在了
- 对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引
- MyISAM只缓存索引，不缓存真实数据，InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存

#### 2.MyISAM引擎:主要的非事务处理存储引擎
- MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不持事务、行级锁、外键，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复。
- 5.5之前默认的存储引擎
- 优势是访问的 速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用。针对数据统计有额外的常数存储。故而 count()的查询效率很高
- 数据文件结构: (在《第02章_MySOL数据目录》章节已讲)
  - 表名.frm 存储表结构
  - 表名MYD 存储数据(MYData)
  - 表名.MYI 存储索引 (MYIndex)
- 应用场景:只读应用或者以读为主的业务

#### 3.Archive引擎：用于数据存档
![img_4.png](img_4.png)


#### 4.Blackhole引擎：丢弃写操作，读操作会返回空内容
![img_5.png](img_5.png)

#### 5.CSV引擎：存储数据时，以逗号分隔各个数据项
![img_6.png](img_6.png)

#### 6.Memory引擎：至于内存的表
![img_7.png](img_7.png)

#### 7.其他引擎
![img_8.png](img_8.png)

## 二、索引的数据结构

### （一）InnoDB中索引的推演

#### 1.简单的索引设计方案
![img_9.png](img_9.png)

#### 2.InnoDB的索引方案

##### (1) 迭代1次：目录项记录的页
![img_10.png](img_10.png)

##### (2) 迭代2次：多个目录项记录的页
![img_11.png](img_11.png)

##### (3) 迭代3次，目录项记录页的目录页
![img_12.png](img_12.png)

#### 3.常见索引概念

##### (1)聚簇索引

##### (2)二级索引（/辅助索引/非聚簇索引）
> 概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根
据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就
是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

##### (3)联合索引

#### 4.注意事项
- 根节点位置万年不动。实际上，一个B+Tree索引的根节点自索引创建时起就被创建了，且不会再移动。

### （二） MyISAM中的索引



## 二、SQL优化

#### 1.哪些维度可以进行数据库调优？
- 索引失效，没有充分利用索引     ———— 建立索引
- 关联查询太多JOIN (设计缺陷或不得已的需求) --SQL优化
- 服务器调优及各个参数设置 (缓冲、线程数等)--调整my.cnf
- 数据过多--分库分表

```markdown
关于数据库调优的知识点非常分散。不同的 DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解
```
  把 SQL 查询优化分成两个部分，逻辑查询优化和物理查询优化。虽然 SOL 查询优化的技术有很多，但是大方向上完全可以分成、物理查询优化 和 逻辑查询优化 两大块。
- 物理查询优化则是通过 索引和 表连接方式 等技术来进行优化，这里重点需要掌握索引的使用。 
- 逻辑查询优化就是通过 SOL 等价变换 提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高.

## MySQL常见的7中日志